多线程 -- 同步
------------

# 锁对象
Lock用于保证线程安全, 确保任何时刻, 只有一个线程进入临界区;      
使用Lock保护的代码块基本如下:

        lock.lock();
        try {
            // some code
        }finally {
            lock.unlock();
        }

上面代码结构保证同一时刻,只有一个线程运行临界区的代码; 一旦一个线程持有了锁对象, 其他任何线程都无法通过lock语句; 其他线程调用lock时, 都会被阻塞, 直到上一线程释放锁对象;

## ReentrantLock (重入锁)
锁是可重入的: **线程可以重复获取已经持有的锁**;  锁有一个持有计数,用来跟踪lock方法的嵌套调用;  **线程在每一次调用lock后都要调用unlock来释放锁**;     

## ReadWriteLock (读写锁)

# Condition (条件对象)
线程进入临界区后, 却发现要满足条件, 才能继续执行, 这时需要释放锁(不然就死锁了), 等待满足条件时, 接着执行;     
条件对象, 即用来解决上面的问题, 用于去管理已经获取锁对象,去不能做有用工作的线程;  

通常示例如下:

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    lock.lock();
    try {
        while ( isSupport ){
            // 释放lock, 同时阻塞该线程, 等待条件满足
            condition.await();
        }

        // some code
    }finally {
        lock.unlock();
    }  

**一个锁对象可以有多个条件对象**, 可以用`newCondition`方法获取一个条件对象;     
**不满足条件时调用`Condition.await`方法**释放锁, 同时当前线程会被阻塞; 当一个线程调用await方法后, 该线程就没办法重新激活自身, 需等待其他线程通知;        
其他线程运行后, 调用`Condition.signalAll`方法, 通知所有阻塞等待的线程解除阻塞; 原先被阻塞的进程再次竞争, 获取锁对象, 继续访问;     
被解除阻塞的线程, 被唤醒后, 可能仍不满足条件, 所以一般使用 while 语句, 判断条件是否满足;       

## 小结
- 锁用来保护代码片段, 任何时刻只能有一个线程执行被保护的代码;
- 锁可以拥有一个或多个相关的条件对象;
- 每个条件对象管理那些已经进入被保护的代码段却还不能运行的线程;


# synchronized & 对象锁
每一个Java对象, 都有一个内部锁;     
如果方法使用synchronized关键字, 那么对象锁将会保护整个方法; 即要调用该方法, 线程先必须获取该对象的对象锁;    
对象的内部锁,只有一个条件对象; 使用方法就是Object的 wait, notifyAll 方法;
使用内部锁, 除了在方法上加上synchronized关键字, 还可以使用`synchronized(obj){...}`代码段

# Volatile
