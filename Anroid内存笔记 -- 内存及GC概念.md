内存及GC
----

## Java内存区域
Java虚拟机在执行Java程序时, 会把管理的内存, 分为几个区域;       
平时我们一般粗略的分成栈和堆; 栈存放对象引用指针, 堆则存放栈中指针指向的对象;       

### Java虚拟机栈
1. 线程私有, 生命周期和Thread相同;     
2. 虚拟机栈描述的是Java方法执行的内存模型: 每个方法执行时,都会创建一个栈帧, 用于存储局部变量表,操作数栈,动态链接,方法出口等信息;每一个方法执行,都对应一个栈帧在虚拟机栈中入栈到出栈;           
3. **平时我们说的栈,即局部变量表; 它存放了编译器可知的各种基本数据类型, 和对象引用等**

### Java堆
1. Java堆是被所有线程共享内存区域, 在虚拟机启动时创建;     
2. **用来存放对象实例, 几乎所有的对象实例和数组都在此分配内存;**         
3. Java堆是内存回收的主要区域,很多时候称之为GC堆

### 方法区
1. 各个线程共享的内存区域
2. 用来存放被虚拟机加载的类信息,常量,静态变量,编译器编译后的代码等
3. 也称之为Non-Heap(非堆), 自己程序开发一般不关注 - -

## 垃圾收集器
gc收集时, 需要完成3件事:    
1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

### 判断那些内存需要回收
回收时,肯定要确定哪些对象要被回收,要判断哪些对象已死(即不可达);   

#### 引用计数法
给对象一个引用计数器, 每当一个地方引用它时, 计数器加1; 当引用失效时, 计数器减1; 任何时候计数器为0的对象, 即不可达对象, 可被回收;       
引用技术简单, 但遇见相互引用时, 无法判定; eg, A引用B, B同时引用A, A和B都不再有其他任何引用, 实际对象不可访问, 但是引用计数器却不为0;

#### 可达性分析
通过一系列GC Root对象作为起点, 从这些节点向下搜索,搜索走过的路径称之为引用链, 当一个对象到GC Root没有任何引用链来连接时, 则此对象不可达, 可以用来回收;      
而用来作为GC Root的对象有下面几种:   
1. 虚拟机栈,即本地变量表中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈JNI, 即Native方法引用的对象

### 垃圾收集算法

#### 标记-清除算法
Mark-Sweep算法,如同名称一样, 分标记和清楚两步: 首先标记出需要回收的对象, 在标记完成后, 统一回收所有被标记的对象;       
主要有2个不足: 一是效率, 标记和清除效率都不高; 二是空间问题, 清除后会产生大量的不连续的内存碎片, 空间碎片太多,可能导致程序运行时, 需要分配较大内存的对象时, 无法找到足够的连续内存而不得不在一次触发gc;

#### 复制算法
为了解决效率问题, Copying的收集算法出现了, 将内存分为容量相等的两块, 每次只使用其中一块, 当一块内存用完时, 就将还存活着的对象复制到另一块上去, 然后把已使用过的内存一次清理;

#### 标记-整理算法
先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间;

#### 分代收集算法
将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老生代的内存空间。对于新生代适用于复制算法，而对于老年代则采取标记-整理,或者标记-清除算法

### 垃圾收集器
收集器是真正实现收集算法的地方,有各种版本, 主要说下CMS

#### CMS收集器
Concurrent Mark Sweep, 名称可以看出是基友标记-清除算法的收集器; 为了使用回收停顿时间(Stop The World`)最短为目标的收集器;     
工作流程分为下面几个步骤:    
1. 初始标记, CMS initial mark
2. 并发标记, CMS concurrent mark
3. 重新标记, CMS remark
4. 并发清楚, CMS concurrent sweep

其中,初始标记和重新标记需要Stop The World. 初始标记仅标记GC Root能直接关联的对象; 并发标记即进行初始标记后的引用可达遍历; 重新标记则是修正并发标记期间程序继续运行而导致标记变动的对象;

